= Rich Text
:toc: right
:imagesdir: media/
:sourcedir: ../src

Enonic provides a link:https://developer.enonic.com/docs/xp/stable/cms/pages/text[text] component that allows you to create rich text content using a WYSIWYG editor.
And the good news is, you don't need to configure anything in either XP or Next.js -- it works out of the box.

But did you know that you can also render custom HtmlArea input fields with rich text component as well ?

To do it we need to follow 3 simple steps:

1. Set input type to `HtmlArea`
2. Update the query for that input to fetch all the data for the rich text component
3. Use RichTextView component to render the rich text field

Let's take `bio` input field from `Person` content type and convert it to a rich text field!

== HtmlArea input type

If we take a look at the `Person` content type, `bio` input field is already of `HtmlArea` type, so we don't need to do anything in the Enonic app.

.src/main/resources/site/content-types/person/person.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<content-type xmlns="urn:enonic:xp:model:1.0">
  <display-name>Person</display-name>
  <description>Historical or living human</description>
  <super-type>base:structured</super-type>
  <form>
    <input type="ImageSelector" name="photos">
      <label>Photos</label>
      <occurrences minimum="0" maximum="0"/>
    </input>
    <input type="HtmlArea" name="bio">
      <label>Bio</label>
      <occurrences minimum="1" maximum="1"/>
      <config>
        <exclude>NumberedList Outdent Indent SpecialChar Anchor Table PasteModeSwitcher</exclude>
      </config>
    </input>
    <input type="Date" name="dateofbirth">
      <label>Birth Date</label>
       <occurrences minimum="0" maximum="1"/>
    </input>
  </form>
</content-type>
----

== Update the query

The main difference of rich text component from the plain text is that it needs certain data fetched from Enonic XP.
Luckily for us, we don't have to worry about the details, because Next.XP has a nice helper function that takes field name and generates the query for us:

[source,Typescript]
----
import { richTextQuery } from '@enonic/nextjs-adapter';
...
const htmlAreaFieldQuery = richTextQuery("bio");
----

Now, let's replace `bio` field in our `getPerson` query with `richTextQuery('bio')`.

This will query all the data needed for the rich text component to be able to render the `bio` field:

[source,Typescript]
----
include::{sourcedir}/components/queries/getPerson.ts[]
----

== Use RichTextView component

Finally, we need to update the `Person` view to render the `bio` field with the rich text component.

Locate the following line in `Person.tsx`:

.src/components/views/Person.tsx
[source,jsx]
----
<p>{bio}</p>
----

And replace it with the following:

[source,jsx]
----
import RichTextView from '@enonic/nextjs-adapter/views/RichTextView';

...

<RichTextView data={bio} meta={meta}></RichTextView>
----

Congratulations!
You have successfully converted the `bio` text field to a rich text component!

== Macros

Macros are special tags that can be used to insert dynamic content into the rich text field.

As long as you have the macro defined in your Enonic XP app, you will be able to insert them in the Html Area editor.

But in order for them to be rendered by the Rich Text component in Next.XP, you need to provide the macro implementations.

You do it similarly to any other component by adding it to the `ComponentRegistry` in the `_mappings.ts` file:

.src/components/_mappings.ts
[source,jsx]
----
import { ComponentRegistry } from '@enonic/nextjs-adapter';
import PanelMacro from './macros/PanelMacro';
...
ComponentRegistry.addMacro('com.enonic.app.panelmacros:panel', {
    view: PanelMacro,
    configQuery: `{
                      body
                      header
                  }`
});
----

Where `PanelMacro` is a React component that will render the macro content:

.src/components/macros/PanelMacro.tsx
[source,jsx]
----
include::{sourcedir}/components/macros/PanelMacro.tsx[]
----

In the next chapter we will look into <<templates#, page templates>>.
Page templates allow us to reuse a page definition across multiple content items.
